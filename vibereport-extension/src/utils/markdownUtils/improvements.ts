import * as crypto from 'crypto';
import { MARKERS } from '../markdownMarkers.js';
import { extractBetweenMarkers } from './markerOps.js';

/**
 * ê°œì„  í•­ëª©ì˜ ê³ ìœ  IDë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * @description ì œëª©ê³¼ ì„¤ëª…ì˜ ë‚´ìš©ì„ ê¸°ë°˜ìœ¼ë¡œ MD5 í•´ì‹œë¥¼ ìƒì„±í•˜ì—¬
 * 12ìë¦¬ì˜ ê³ ìœ  ì‹ë³„ìë¥¼ ë§Œë“­ë‹ˆë‹¤. ë™ì¼í•œ ë‚´ìš©ì€ í•­ìƒ ë™ì¼í•œ IDë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * @param title - ê°œì„  í•­ëª© ì œëª©
 * @param description - ê°œì„  í•­ëª© ì„¤ëª…
 * @returns 12ìë¦¬ 16ì§„ìˆ˜ í•´ì‹œ ë¬¸ìì—´
 *
 * @example
 * ```typescript
 * const id = generateImprovementId('í…ŒìŠ¤íŠ¸ ì¶”ê°€', 'ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.');
 * // id: 'a1b2c3d4e5f6'
 * ```
 */
export function generateImprovementId(title: string, description: string): string {
  const content = `${title}:${description}`.toLowerCase().trim();
  const hash = crypto.createHash('md5').update(content).digest('hex');
  return hash.substring(0, 12);
}

const EXPLICIT_IMPROVEMENT_ID_REGEX = /^[a-z][a-z0-9-]*-\d{3}$/;

/**
 * ì„ íƒëœ í…ìŠ¤íŠ¸ì—ì„œ ëª…ì‹œì ì¸ ê°œì„  í•­ëª© IDë¥¼ ì¶”ì¶œí•©ë‹ˆë‹¤.
 *
 * @description ë ˆí¬ì§€í† ë¦¬ì—ì„œ ì‚¬ìš©í•˜ëŠ” ê°œì„  í•­ëª© ID í˜•ì‹(`<kebab-case>-<3 digits>`)ì„
 * ë‹¤ì–‘í•œ ì„ íƒ íŒ¨í„´ì—ì„œ ì•ˆì •ì ìœ¼ë¡œ ì¶”ì¶œí•˜ê¸° ìœ„í•œ ìˆœìˆ˜ í•¨ìˆ˜ì…ë‹ˆë‹¤.
 *
 * ì§€ì› íŒ¨í„´:
 * - ë§ˆí¬ë‹¤ìš´ í…Œì´ë¸” í–‰: `**ID**`ë¥¼ í¬í•¨í•˜ê³ , ë°±í‹± ì½”ë“œ ìŠ¤íŒ¬ìœ¼ë¡œ IDê°€ í‘œê¸°ëœ ê²½ìš°
 * - í”„ë¡¬í”„íŠ¸ ë¬¸ì¥: `Linked Improvement ID:` ë¼ì¸ì— ë°±í‹± ì½”ë“œ ìŠ¤íŒ¬ìœ¼ë¡œ IDê°€ í‘œê¸°ëœ ê²½ìš°
 * - ì¼ë°˜ í´ë°±: í…ìŠ¤íŠ¸ ë‚´ ë°±í‹± ì½”ë“œ ìŠ¤íŒ¬ ì¤‘ ì²« ë²ˆì§¸ë¡œ ID í˜•ì‹ê³¼ ì¼ì¹˜í•˜ëŠ” í† í°
 *
 * @param text - ê²€ìƒ‰í•  í…ìŠ¤íŠ¸(ì„ íƒ ì˜ì—­)
 * @returns ì¶”ì¶œëœ ê°œì„  í•­ëª© ID ë˜ëŠ” ì°¾ì§€ ëª»í•˜ë©´ null
 */
export function extractImprovementIdFromText(text: string): string | null {
  const normalized = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
  const lines = normalized.split('\n');

  // 1) Table row format (contains **ID** and a backticked value)
  for (const line of lines) {
    if (!line.includes('**ID**')) continue;
    for (const match of line.matchAll(/`([^`]+)`/g)) {
      const token = match[1].trim();
      if (EXPLICIT_IMPROVEMENT_ID_REGEX.test(token)) return token;
    }
  }

  // 2) Linked ID format in English prompts
  for (const line of lines) {
    if (!line.includes('Linked Improvement ID:')) continue;
    for (const match of line.matchAll(/`([^`]+)`/g)) {
      const token = match[1].trim();
      if (EXPLICIT_IMPROVEMENT_ID_REGEX.test(token)) return token;
    }
  }

  // 3) Generic fallback: first backticked token matching the explicit format
  for (const match of normalized.matchAll(/`([^`]+)`/g)) {
    const token = match[1].trim();
    if (EXPLICIT_IMPROVEMENT_ID_REGEX.test(token)) return token;
  }

  return null;
}

/**
 * íŒŒì‹±ëœ ê°œì„  í•­ëª© ì¸í„°í˜ì´ìŠ¤
 *
 * @description ë§ˆí¬ë‹¤ìš´ì—ì„œ íŒŒì‹±ëœ ê°œì„  í•­ëª©ì˜ êµ¬ì¡°ë¥¼ ì •ì˜í•©ë‹ˆë‹¤.
 */
export interface ParsedImprovementItem {
  /** í•­ëª©ì˜ ê³ ìœ  ID (ë‚´ìš© ê¸°ë°˜ í•´ì‹œ) */
  id: string;
  /** ìš°ì„ ìˆœìœ„ (P1: ê¸´ê¸‰, P2: ì¤‘ìš”, P3: ê°œì„ , OPT: ìµœì í™”) */
  priority: 'P1' | 'P2' | 'P3' | 'OPT';
  /** í•­ëª© ì œëª© */
  title: string;
  /** í•­ëª© ìƒì„¸ ì„¤ëª… */
  description: string;
  /** ì ìš© ì™„ë£Œ ì—¬ë¶€ */
  applied: boolean;
  /** ì›ë³¸ ë§ˆí¬ë‹¤ìš´ í…ìŠ¤íŠ¸ */
  rawContent: string;
}

function normalizeMarkdownText(content: string): string {
  return content.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
}

function isAppliedImprovement(rawContent: string): boolean {
  const lower = rawContent.toLowerCase();
  return (
    rawContent.includes(MARKERS.APPLIED_MARKER) ||
    rawContent.includes('âœ…') ||
    lower.includes('[ì™„ë£Œ]') ||
    lower.includes('[ì ìš©ë¨]')
  );
}

function isImprovementHashId(value: string): boolean {
  return /^[0-9a-f]{12}$/i.test(value.trim());
}

function isLikelyImprovementIdLine(line: string): boolean {
  const normalized = line.replace(/\*\*/g, '').toLowerCase();
  if (!normalized.includes('id')) return false;

  if (normalized.includes('í•­ëª©')) return true;
  if (normalized.includes('item')) return true;

  const trimmed = normalized.trim();
  const maybeBlockquote = trimmed.startsWith('>') ? trimmed.slice(1).trim() : trimmed;
  return maybeBlockquote.startsWith('id');
}

function tryExtractImprovementIdFromLine(line: string): string | null {
  const normalized = line.replace(/\*\*/g, '').toLowerCase();
  if (!normalized.includes('id')) return null;

  const codeSpanMatch = line.match(/`([^`]+)`/);
  if (codeSpanMatch && isImprovementHashId(codeSpanMatch[1])) {
    return codeSpanMatch[1].toLowerCase();
  }

  const rawMatch = line.match(/([0-9a-f]{12})/i);
  if (rawMatch && isImprovementHashId(rawMatch[1])) {
    return rawMatch[1].toLowerCase();
  }

  return null;
}

function extractImprovementIdAndCleanBody(bodyLines: string[]): {
  id: string | null;
  body: string;
} {
  for (let index = 0; index < bodyLines.length; index++) {
    const line = bodyLines[index];
    if (!isLikelyImprovementIdLine(line)) continue;

    const id = tryExtractImprovementIdFromLine(line);

    const cleanedLines = bodyLines.filter((_, i) => i !== index);
    return { id, body: cleanedLines.join('\n').trim() };
  }

  return { id: null, body: bodyLines.join('\n').trim() };
}

type ImprovementPriority = 'P1' | 'P2' | 'P3';

function parsePriorityItemHeaderLine(
  line: string
): { priority: ImprovementPriority; title: string } | null {
  const trimmed = line.trim();

  const headingMatch = trimmed.match(/^#{2,4}\s*\[?(P[123])(?:-\d+)?\]?\s*(.+)$/i);
  if (headingMatch) {
    return {
      priority: headingMatch[1].toUpperCase() as ImprovementPriority,
      title: headingMatch[2].trim(),
    };
  }

  const bulletMatch = trimmed.match(/^-+\s*\[?(P[123])(?:-\d+)?\]?\s*(.+)$/i);
  if (bulletMatch) {
    return {
      priority: bulletMatch[1].toUpperCase() as ImprovementPriority,
      title: bulletMatch[2].trim(),
    };
  }

  return null;
}

function parseOptimizationItemHeaderLine(line: string): { title: string } | null {
  const trimmed = line.trim();
  const match = trimmed.match(/^#{2,4}\s*[ğŸš€âš™ï¸]\s*([^\n(]+?)\s*\(OPT-\d+\)[^\n]*$/i);
  if (!match) return null;
  return { title: match[1].trim() };
}

function isHorizontalRuleLine(line: string): boolean {
  return line.trim() === '---';
}

function isHeadingLine(line: string): boolean {
  return /^#{2,4}\s+/.test(line.trim());
}

function parseImprovementItemsFromText(source: string): ParsedImprovementItem[] {
  const lines = source.split('\n');
  const items: ParsedImprovementItem[] = [];

  let i = 0;
  while (i < lines.length) {
    const headerLine = lines[i];
    const priorityHeader = parsePriorityItemHeaderLine(headerLine);
    const optHeader = parseOptimizationItemHeaderLine(headerLine);

    if (!priorityHeader && !optHeader) {
      i++;
      continue;
    }

    const startIndex = i;
    i++;

    while (i < lines.length) {
      const nextLine = lines[i];
      if (parsePriorityItemHeaderLine(nextLine) || parseOptimizationItemHeaderLine(nextLine)) {
        break;
      }

      if (isHorizontalRuleLine(nextLine)) {
        let j = i + 1;
        while (j < lines.length && lines[j].trim() === '') {
          j++;
        }
        if (j < lines.length && isHeadingLine(lines[j])) {
          break;
        }
      }

      i++;
    }

    const rawContent = lines.slice(startIndex, i).join('\n').trim();
    const { id: explicitId, body } = extractImprovementIdAndCleanBody(
      lines.slice(startIndex + 1, i)
    );
    const applied = isAppliedImprovement(rawContent);

    if (priorityHeader) {
      const id = explicitId ?? generateImprovementId(priorityHeader.title, body);
      items.push({
        id,
        priority: priorityHeader.priority,
        title: priorityHeader.title,
        description: body,
        applied,
        rawContent,
      });
      continue;
    }

    if (optHeader) {
      const id = explicitId ?? generateImprovementId(optHeader.title, body);
      items.push({
        id,
        priority: 'OPT',
        title: optHeader.title,
        description: body,
        applied,
        rawContent,
      });
      continue;
    }
  }

  return items;
}

/**
 * ë§ˆí¬ë‹¤ìš´ ë‚´ìš©ì—ì„œ ê°œì„  í•­ëª© ëª©ë¡ì„ íŒŒì‹±í•©ë‹ˆë‹¤.
 *
 * @description `### [P1] ì œëª©` ë˜ëŠ” `- [P1] ì œëª©` í˜•ì‹ì˜ ê°œì„  í•­ëª©ì„ íŒŒì‹±í•˜ì—¬
 * êµ¬ì¡°í™”ëœ ë°°ì—´ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤. ì ìš© ì™„ë£Œ ë§ˆì»¤ê°€ ìˆëŠ” í•­ëª©ì€ `applied: true`ë¡œ í‘œì‹œë©ë‹ˆë‹¤.
 *
 * @param content - íŒŒì‹±í•  ë§ˆí¬ë‹¤ìš´ ë¬¸ìì—´
 * @returns íŒŒì‹±ëœ ê°œì„  í•­ëª© ë°°ì—´
 *
 * @example
 * ```typescript
 * const content = `
 * ### [P2] í…ŒìŠ¤íŠ¸ ì¶”ê°€
 *
 * ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.
 * `;
 * const items = parseImprovementItems(content);
 * // items: [{ id: '...', priority: 'P2', title: 'í…ŒìŠ¤íŠ¸ ì¶”ê°€', ... }]
 * ```
 */
export function parseImprovementItems(content: string): ParsedImprovementItem[] {
  const normalized = normalizeMarkdownText(content);

  const blocks: string[] = [];
  const improvementListBlock = extractBetweenMarkers(
    normalized,
    MARKERS.IMPROVEMENT_LIST_START,
    MARKERS.IMPROVEMENT_LIST_END
  );
  if (improvementListBlock !== null) blocks.push(improvementListBlock);

  const optimizationBlock = extractBetweenMarkers(
    normalized,
    MARKERS.OPTIMIZATION_START,
    MARKERS.OPTIMIZATION_END
  );
  if (optimizationBlock !== null) blocks.push(optimizationBlock);

  const source = blocks.length > 0 ? blocks.join('\n\n') : normalized;
  return parseImprovementItemsFromText(source);
}

/**
 * ì ìš©ëœ í•­ëª©ì„ í•„í„°ë§í•˜ì—¬ ë¯¸ì ìš© ê°œì„  í•­ëª©ë§Œ í¬í•¨í•˜ëŠ” ë³´ê³ ì„œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * @description ê°œì„  ë³´ê³ ì„œì—ì„œ ì´ë¯¸ ì ìš©ëœ í•­ëª©ë“¤ì„ ì œê±°í•˜ê³ ,
 * ìš°ì„ ìˆœìœ„ë³„ë¡œ ê·¸ë£¹í™”ëœ ë¯¸ì ìš© í•­ëª©ë§Œ í¬í•¨í•˜ëŠ” ë§ˆí¬ë‹¤ìš´ ë¬¸ìì—´ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
 *
 * @param content - ì›ë³¸ ê°œì„  ë³´ê³ ì„œ ë§ˆí¬ë‹¤ìš´ ë‚´ìš©
 * @param appliedIds - ì ìš© ì™„ë£Œëœ í•­ëª© IDë“¤ì˜ Set
 * @returns ë¯¸ì ìš© í•­ëª©ë§Œ í¬í•¨ëœ ë§ˆí¬ë‹¤ìš´ ë¬¸ìì—´
 *
 * @example
 * ```typescript
 * const appliedIds = new Set(['abc123', 'def456']);
 * const filtered = filterAppliedImprovements(reportContent, appliedIds);
 * ```
 */
export function filterAppliedImprovements(content: string, appliedIds: Set<string>): string {
  const items = parseImprovementItems(content);

  // ì ìš©ë˜ì§€ ì•Šì€ í•­ëª©ë§Œ í•„í„°ë§
  const pendingItems = items.filter(item => !appliedIds.has(item.id) && !item.applied);

  if (pendingItems.length === 0) {
    return 'ëª¨ë“  ê°œì„  í•­ëª©ì´ ì ìš©ë˜ì—ˆìŠµë‹ˆë‹¤! ğŸ‰';
  }

  // ìš°ì„ ìˆœìœ„ë³„ ê·¸ë£¹í™”
  const byPriority: Record<string, ParsedImprovementItem[]> = {
    P1: [],
    P2: [],
    P3: [],
    OPT: [],
  };

  for (const item of pendingItems) {
    if (byPriority[item.priority]) {
      byPriority[item.priority].push(item);
    }
  }

  const lines: string[] = [];

  for (const priority of ['P1', 'P2', 'P3', 'OPT'] as const) {
    const priorityItems = byPriority[priority];
    if (priorityItems.length > 0) {
      lines.push(`\n## ${getPriorityLabel(priority)} (${priorityItems.length}ê°œ)`);
      lines.push('');

      for (const item of priorityItems) {
        lines.push(`### [${priority}] ${item.title}`);
        lines.push('');
        lines.push(item.description);
        lines.push('');
      }
    }
  }

  return lines.join('\n');
}

/**
 * ê°œì„  í•­ëª©ì„ AI ì—ì´ì „íŠ¸ì— ë¶™ì—¬ë„£ê¸° ê°€ëŠ¥í•œ í”„ë¡¬í”„íŠ¸ í˜•ì‹ìœ¼ë¡œ í¬ë§·í•©ë‹ˆë‹¤.
 *
 * @description ê°œì„  í•­ëª©ì˜ ì œëª©, ì„¤ëª…, ìš°ì„ ìˆœìœ„, IDë¥¼ í¬í•¨í•œ
 * ë³µì‚¬-ë¶™ì—¬ë„£ê¸° ê°€ëŠ¥í•œ í”„ë¡¬í”„íŠ¸ ë¬¸ìì—´ì„ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * @param item - íŒŒì‹±ëœ ê°œì„  í•­ëª© ê°ì²´
 * @returns AI ì—ì´ì „íŠ¸ìš© í”„ë¡¬í”„íŠ¸ ë¬¸ìì—´
 *
 * @example
 * ```typescript
 * const item: ParsedImprovementItem = { ... };
 * const prompt = formatImprovementAsPrompt(item);
 * // Copilot Chatì— ë¶™ì—¬ë„£ê¸° ê°€ëŠ¥í•œ í˜•ì‹
 * ```
 */
export function formatImprovementAsPrompt(item: ParsedImprovementItem): string {
  return `## ${item.title}

${item.description}

---
ìš°ì„ ìˆœìœ„: ${item.priority}
í•­ëª© ID: ${item.id}

ìœ„ ê°œì„  ì‚¬í•­ì„ í˜„ì¬ í”„ë¡œì íŠ¸ì— ì ìš©í•´ì£¼ì„¸ìš”.`;
}

function getPriorityLabel(priority: 'P1' | 'P2' | 'P3' | 'OPT'): string {
  switch (priority) {
    case 'P1':
      return 'ğŸ”´ ê¸´ê¸‰ (P1)';
    case 'P2':
      return 'ğŸŸ¡ ì¤‘ìš” (P2)';
    case 'P3':
      return 'ğŸŸ¢ ê°œì„  (P3)';
    case 'OPT':
      return 'ğŸš€ ìµœì í™” (OPT)';
  }
}

